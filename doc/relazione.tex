\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}


\title{Documentazione  Web App}
\author{Castelli Marco}
\date{Anno accademico 2021-2022}


\begin{document}

\maketitle
\newpage


\tableofcontents

\newpage

\section{Introduzione}

La web application sviluppata permette di generare, grazie al <<LookBack Apriori Algorithm>> un insieme di regole, dati come input un'insieme di dati e dei setting scelti dall'utente. Una volta avvenuta la generazione delle regole l'utente ha la possibilità di inserire una query. Il software effettuerà il match delle regole precedentemente generate e la query stessa.

Questa web application, che rappresenta il server, servirà poi per la creazione di un software di più grandi dimensioni. Il software sarà formato da una mobile app  che manderà delle richieste API al server, esso genererà le regole prendendo i dati da un database e ritornerà un risultato all'utente.

\subsection{LookBack Apriori Algorithm}
L'algoritmo è un estensione del classico Algoritmo Apriori, infatti effettua un processo di data mining dei dati utilizzando anche il time slot dei dati generati.

 I dati processati  rappresentano le attività fisiche e la qualità del riposo dell'utente negli ultimi giorni, in particolare per ogni attività vi è la durata in minuti della stessa. L'algoritmo  analizza i dati dell'utente e restituisce come risultato una lista di regole. 

Queste regole vengono generate in base ai dati del singolo utente e rappresentano quali attività l'utente dovrebbe svolgere per ottenere un buon riposo.

\section{Organizzazione del codice}
Il file principale è <<app.py>> che rappresenta la routes delle varie pagine html, in esso vengono richiamate le varie funzioni per gestire i dati ottenuti dai form.

Tutte le funzioni utilizzate sono state organizzate in un file <<utilities.py>> mentre l'algoritmo di data mining, ossia <<LookBack Apriori Algorithm>>, è definito in un file a parte .

Le pagine html si trovano all'interno della cartella <<templates>> mentre nella cartella <<static>> è presente il codice css.

All'interno della cartella <<Setting>> sono presenti tutte le regole che sono state generate durante l'utilizzo del software. Il nome di ogni file rappresenta il setting utilizzato per generare le regole, in particolare si specifica il dataset  e i parametri:  sleep value, temporal window, min support, min confidence.

Nella cartella <<Data>> sono presenti delle sottocartelle che contengono i dati di alcuni utenti.

\section{Descrizione file principali}
\subsection{<<app.py>>}
In un certo modo rappresenta il main del nostro programma.
Prima delle <<routes>> vengono dichiarate tutte le librerie  utilizzate e dopodichè vengono definite delle variabili globali in modo che siano accessibili all'interno delle varie routes.

La prima route è <<settingRules>> in cui viene semplicemente richiamata la pagina <<settingRules.html>>, in questa pagina html si compila il form con le informazioni per il setting: dataset , sleep value, temporal window, min support, min confidence. 

Dopo aver compilato il form i dati vengono passatti alla route <<rulesGeneration>>, qui vengono effettuati vari controlli sulla correttezza dei dati, qualora non lo fossero l'utente viene reindirizzatto alla pagina <<settingRules.html>>. Se invece i dati fossero corretti si verifica se è già presente un file con quei  setting, in modo da non dover rigenerare le regole, se non lo fosse, si controlla anche se è possibile generare le regole a partire da un file già presente ma con diversi setting.

 Se non è vero nessuno dei due casi precedenti allora, bisogna necessariamente  richiamare la funzione di generazione delle regole <<LookBack Apriori Algorithm.py>> che restituisce una lista formata dalle regole generate, già ordinate e successivamente si salvano le regole su un file all'interno della cartella <<Setting>>.

Avvenuta la generazione delle regole si viene reindirizzati alla pagina <<rulesGeneration.html>> che mostra le prime venti regole generate, ordinate per support, completezza e dimensione; vengono inoltre mostrati i setting utilizzati e il numero totale delle regole generate.

Nella navbar è presente la voce <<Match Query>>, una volta premuta, si viene reindirizzati alla pagina <<matchQueryForm.html>> dove l'utente ha la possibilià di inserire una query per il matching.

Inserita la query e premuto l'apposito bottone si viene reindirizzatti alla route <<matchingQuery>>, qui viene controllata la correttezza della query e successivamente viene richiamata la funzione di matching che mostra il risultato all'interno della pagina <<matchingQuery.html>>.

L'utente ha sempre a disposizione la navbar che può utilizzare per tornare a visualizzare le regole generate oppure per creare nuove regole con nuovi setting.

\subsection{<<LookBack Apriori Algorithm.py>>}
Il codice dell'algoritmo è stato messo sotto forma di funzione, il setting viene passato come parametro alla funzione e tali parametri vengono utilizzato dall'algoritmo per generare le regole secondo onerosi calcoli.
Viene richiamata la funzione di ordinamento sulle regole ed infine vengono restituite tutte le regole generate.


\section{Descrizione funzioni presenti nel file utilities}
\subsection{dataRange}
Richiamata nella route <<settingRules>> verifica che i dati inseriti nel form appartengano ad un determinato range di valori.

Restituisce eventualmente un messaggio di errore e booleano.

\subsection{isQueryValid}
Richiamata nella route <<matchingQuery>> verifica che la query inserita sia ben formata, ossia contenga come attività HA,MA,LA,ZL,R con annesso un time slot (es: t2). Il time slot non deve superare la temporal window che l'utente ha inserito nei setting iniziali.

Restituisce un booleano e un messaggio.

\subsection{addCriteria}
Richiamata all'interno della funzione rulesSorting, altera la struttura di ogni elemento della lista di regole aggiungendo un campo completeness e size.

Utilità: facilità la successiva operazione di ordinamento.

Restituisce la lista di regole modificata.

\subsection{rulesSorting}
Richiamata all'interno del file <<LookBack Apriori Algorithm.py>> restituisce una nuova lista dove le regole sono ordinate per support, completeness, size.

\subsection{splitFile}
Richiamata in due diverse route quando abbiamo necessità di leggere le regole dal file, ad esempio inseriamo un setting precedentemente generato oppure è possibile utilizzare un'altro file da cui leggere le regole (setting implicito).

Scorre il file e memorizza tutte le informazioni in esso presenti, in particolare i valori dei setting, la sola lista di regole (campo ''rule'' della struttura) e l'intera struttura delle regole.

Restituisce le informazioni precedenti.

\subsection{alreadySetting}
Richiamata nella route <<rulesGeneration>>.

Verifica se nella cartella <<Setting>> è già presente un file con il nome passato come parametro.

Restituisce un booleano

\subsection{rulesImplicitGeneration}
Richiamata nella route <<rulesGeneration>>.

Dato un setting verifica se esiste un file  dal quale è possibile prendere un sottoinsieme di regole (setting implicito).

Utilità: vogliamo generare un insieme di regole a partire da un setting ma, abbiamo a disposizione un file simile nel quale le regole sono già contenute.

\subsection{saveSetting}
Richiamata nella route <<rulesGeneration>>.

Consente di creare un file con il nome del setting, in esso viene salvatosia il setting che tutte le regole generate (solo campo ''rule'').

\subsection{takeRuleImplicit}
Richiamata nelle routes <<rulesGeneration>> e <<matchingQuery>>. Usata quando troviamo un file che contiene le regole specificate in un nuovo setting, per ottenere un sottoinsieme delle regole.

Consente di ottenere solamente le regole con support e confidence specificate.

Resituisce le sole regole e l'intera struttura delle regole.

\subsection{findMatching}
Funzione principale per il matching delle regole, in essa vengono fatte delle operazioni preliminari sulla query e sull'insieme di regole, dopodichè vengono richiamate le funzioni specifiche per il matching, una alla volta in ordine di importanza.

Il confronto tra la query dell'utente e le regole presenti, viene fatto solamente sulle attività diverse da t0.

Restituisce se trova la regola altrimenti null.

\subsection{ExactMatch}
Primo criterio per il matching: scorre tutta la lista di regole e se trova una regole che è identica alla query dell'utente la restituisce. 

Esempio di ExactMatch: 

Query utente: LA\_3\_t3 + MA\_2\_t2 + R\_3\_t1

Match: LA\_3\_t3 + MA\_2\_t2 + R\_3\_t1 + X\_X\_t0

\subsection{Match}
Secondo criterio per il matching: scorre tutta la lista di regole e se trova una regola in cui tutte le attività della "Match" appaiono nello stesso time slot nella query dell'utente, la restituisce.

Esempio di Match: 

Query utente: MA\_2\_t3 + LA\_3\_t3 + MA\_2\_t2 + LA\_1\_t1 + R\_3\_t1

Match: LA\_3\_t3 + MA\_2\_t2 + R\_3\_t1 + X\_X\_t0 

\subsection{PartialMatch}
Terzo criterio per il matching: ci sono delle stesse attività che appaiono nel medesimo time-slot, mentre le altre sono simili, cioè hanno la stessa attività ma intensità diverse. Scorre la lista e se trova la regola la restituisce.

Esempio di PartialMatch: 

Query utente: R\_2\_t3 + LA\_2\_t3 + MA\_2\_t2 + LA\_2\_t1 + R\_2\_t1

Match: LA\_3\_t3 + MA\_2\_t2 + R\_3\_t1 + X\_X\_t0 

\subsection{SimilarMatch}
Quarto criterio per il matching: ogni time slot contiene un'attività che è simile ad un'altra nella match rule.
Scorre la lista e se trova la regola la restituisce.


Esempio di SimilarMatch: 

Query utente: R\_3\_t3 + LA\_2\_t3 + MA\_3\_t2 + LA\_2\_t1 + R\_1\_t1

Match: LA\_3\_t3 + MA\_2\_t2 + R\_3\_t1 + X\_X\_t0


\subsection{isSimilar}
Funzione utilizzata all'interno delle funzioni PartialMatch e SimilarMatch, consente di verificare se un insieme di attività, in un dato time slot (t2), è simile rispetto ad un altro insieme nello stesso time slot.

Due attività sono simili se hanno la stessa attività (es: HA) ma con intensità diverse.

Resituisce una lista con i valori ''Similar'', ''Partial'' e ''False'', che serviranno per controllare il tipo di match.

Se l'array risultato contiene solo "Similar" allora il match è di tipo SimilarMatch, se invece oltre a "Similar" c'è anche "Partial" allora è PartialMatch.

\subsection{splitActivity}
Richiamata in tutte le funzioni di match, consente a partire da una stringa (la regola) di ottenere una lista formata dalle attività in t1,t2,t3, ..., tn 

Esempio: ([[HA\_1\_t3, MA\_2\_t3],[LA\_2\_t2, MA\_1\_t2],[R\_2\_t1, ZL\_2\_t1]])

\subsection{ruleAntecedent}
Consente di ottenere l'antecedente della regola cioè tutto ciò prima di '->', si veda un file all'interno di <<Setting>> per capire meglio.
Viene utilizzata per il matching delle regole.





\end{document}