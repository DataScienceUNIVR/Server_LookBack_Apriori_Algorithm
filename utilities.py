from operator import itemgetter

# function to return error message about form in index
def __dataRange(sleep_value,temporal_window,min_support,min_confidence):
    error=""
    correct=True

    if(sleep_value<1 or sleep_value> 3):
     error= "sleep_value correct range in [1,3];\n"
    if(temporal_window<1 or temporal_window> 3):
     error= error+"temporal_window correct range in [1,3];\n"
    if(min_support>1 or min_support<=0):
     error=error+"min_support correct range in (0,1];\n"
    if(min_confidence<=0 or min_confidence> 1):
     error=error+"min_confidence correct range in (0,1];\n"
    
    if(error!=""):
        correct=False

    return error,correct

# sorting rules from all rules
def rulesSorting(rules,temporal_window):
    __addCriteria(rules,temporal_window)
    rules = sorted(rules, key = itemgetter('support','completeness','size'),reverse=True)
    return rules

# add two new criteria into a list
def __addCriteria(rules,temporal_window):
    for rule in rules:
     priority=0
     for i in range(temporal_window+1):      #[0 .. tem_win]
         if(rule['rule'][:rule['rule'].index('-')].find(("t"+str(i)))!=-1):      #find a if t0, t1,t2, .. (before ->) is in rule
             priority+=1
         else:
            priority-=0.5                   # this is a hole
     rule['completeness']=priority          #add  criteria into list
     rule['size']=len(rule['rule'][:rule['rule'].index('-')])        # add second criteria into a list

    return rules
  
# from a file return temporal window and a list of rules
def __splitFile():
    rules=""
    with open('setting.txt','r') as f:
        res=f.read()

    temporal_window=int(res[:res.index('\n')]) #obtain temporal_window   
    rules=res[res.index('\n')+1:]  #obtain rules as one string
    rules = list(rules.split("\n")) #create a list of rules
    return temporal_window,rules

#create a file_name file to save mining rules and temporal_window
def __saveSetting(temporal_window,rules, file_name):
 
 #obtain only the rule(the string)
 only_rule=(x['rule'] for x in rules)
       
 #save information in a file
 with open(file_name,'w') as f:
  f.write(str(temporal_window)+'\n')
  for e in only_rule:
   f.write(e+'\n')

#find matching betwenn user query and all rules generated by LookBack Apriori Algorithm
# return rule 
def findMatching(my_query, rules):
 
 #delete white space
 my_query.replace(" ","")
 

 for rule in rules:
     rule_antecedent=rule[:rule.index('-')] #take only string before ->
     rule_antecedent.replace(" ", "")       #delete all white space
     
     #1) First criteria: EXACT MATCH
     if my_query==rule_antecedent:
         return rule_antecedent

    # .... complete ...

    